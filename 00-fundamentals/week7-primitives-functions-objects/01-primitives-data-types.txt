Introducción

  existen tipos de datos en javascript

  Undefined
    solo existe un valor para este tipo de dato: undefined

    el valor existe y es tan real como cualquier otro valor

    representa la idea de que no hemos definido un valor intencionalmente

    si bien podemos "invocar" el valor undefined escribiéndolo a mano al igual que podemos escribir 2 o "hola"
      lo más común es que undefined aparezca de manera "natural"
        aparece cuando JavaScript no sabe qué valor asignar
          ejemplo
            si solo declaramos una variable pero no le asignamos un valor
              entonces JavaScript le asignará internamente el valor undefined

    si una variable tiene valor undefined
      de todos modos la variable si existe
        solo que apunta al valor undefined

  Null
    solo existe un valor de este tipo: null

    para transmitir intencionalmente que el valor está ausente

    si te encuentras con algo que es undefined puedes intuir que es un error o que "se te olvidó" asignar un valor
      mientras que cuando te encuentras con null sabes que tú o alguien colocó ese valor intencionalmente


  Booleans
    solo existen dos valores booleanos: true y false

    "truthy" y "falsy"
      todos los valores de JavaScript pueden traducirse en un valor booleano true o false
        esto se logra mediante la función constructora Boolean
          ejm
            Boolean("Hola"); // true -- entonces "Hola" es truthy
            Boolean(null); // false -- entonces "null" es falsy
            Boolean(1000); // true -- entonces 1000 es truthy

        en general es mas facil recordar que valores son falsy, el resto seria truthy
          los valores falsy son
            Boolean(false); // false
            Boolean(undefined); // false
            Boolean(null); // false
            Boolean(""); // false
            Boolean(0); // false
            Boolean(NaN); // false

            * Boolean([]) // truthy (un array vacio no es falsy)

    short-circuit operation
      para operador &&, la regla es la siguiente:
        si el primer operando es true (o "truthy"), retorna inmediatamente el valor del segundo operando (sin importar qué valor sea)
        si el primer operando es false (o "falsy"), retorna inmediatamente ese valor (sin siquiera evaluar el segundo operando)

        ejemplos
          "Hola" && true; // true
          false && "falso"; // false
          10 && 20; // 20
          undefined && null; // undefined

      para el operador ||, la regla es la siguiente:
        si el primer operando es true (o "truthy"), retorna inmediatamente ese valor (sin siquiera evaluar el segundo operando)
        si el primer operando es false (o "falsy"), retorna inmediatamente el valor del segundo operando (sin importar qué valor sea)

        ejemplos
          "Hola" || true; // "Hola"
          false || "falso"; // "falso"
          10 || 20; // 10
          undefined || null; // null

    operador ! (not)
      si el operando es true o "truthy" retornará false, de lo contrario retornará true
        ejemplos
          !true; // false
          !false; // true
          !"Hola"; // false
          !10; // false
          !undefined; // true

    multiples operadores lógicos

      es posible encadenar multiples operadores lógicos
        javaScript ejecutará los operadores en orden de aparición

        los operadores lógicos && y || son "binarios"
          actúan solo sobre 2 operandos
            ejemplo para algo asi:
              true && false && true || false && !false

            para JavaScript, el primer && del ejemplo se lee así:
              true && (...el segundo operando)

            se sabe que el primer operando es true así que retornará el valor del segundo operando
              //          ↓↓Nos concentramos en esta parte ahora↓↓
              true &&     false && (...el segundo operando)

            nos encontramos otra vez con un && pero el primer operando es false
              entonces, el resultado de esta operación false
                sin importar el valor del segundo operando (siguiendo la regla de corto-circuito)
                  JavaScript no necesita calcular más resultados a la derecha

                entonces
                  true && false && true || false && !false; // false

  Numbers
    Otros lenguajes de programación utilizan diferentes tipos de datos para representar diferentes tipos de números
      para JavaScript todo tipo de número es un Number
        sea negativo, positivo, flotante, o numero entero

    sintaxis para operaciones no tan intuitivas
      % - Módulo o Residuo:
            Devuelve el resto de una división entera.
              7 % 3; // 1, porque 7 dividido entre 3 tiene un cociente de 2 y un resto de 1.

      ** - Exponenciación:
            Eleva el primer número a la potencia del segundo número.
              2 ** 3; // 8

      - (Operador unario negativo):
          Devuelve el valor negativo de su operando.
            let x = 5;
            -x; // -5

      + (Operador unario positivo):
          Devuelve su operando convertido a un número.
          A menudo se utiliza para convertir cadenas de texto a números,
          pero si el operando ya es un número, no tiene ningún efecto.

          let x = "3"; // el string "3"
          +x; // 3, el número 3

    matemática de punto flotante
      es una forma de representar números reales en sistemas informáticos
        sirve para representar números muy grandes y muy pequeños de manera eficiente
        su efecto secundario es que no siempre ser 100% precisa
          el mundo ideal de las matemáticas, los números reales son infinitos
            las computadoras no tienen la capacidad de representar esa infinidad de números
            la cantidad de números que existen en el universo de JavaScript es finita

            es por eso que ocurren cosas como esta:
              console.log(0.1 + 0.2);  // 0.30000000000000004

            internamente, 0.1 y 0.2 no son representados con precisión absoluta
              llevando a pequeños errores de redondeo al sumarlos

            otros lenguajes que implementan matemática de punto flotante tienen el mismo inconveniente

      JavaScript puede representar con precisión los números enteros entre
        Number.MIN_SAFE_INTEGER y Number.MAX_SAFE_INTEGER

        Si intentamos hacer cálculos que sobrepasan estos límites empezaremos a perder precisión también:

          console.log(Number.MAX_SAFE_INTEGER + 1); // 9007199254740992 (funciona)
          console.log(Number.MAX_SAFE_INTEGER + 2); // 9007199254740992 (error)
          console.log(Number.MAX_SAFE_INTEGER + 3); // 9007199254740994 (funciona)
          console.log(Number.MAX_SAFE_INTEGER + 4); // 9007199254740996 (funciona)
          console.log(Number.MAX_SAFE_INTEGER + 5); // 9007199254740996 (error)

    Numeros especiales
      el estándar de matemática de punto flotante que utiliza JavaScript
        incorpora ciertos valores especiales
          son valores se utilizan para representar resultados de ciertas operaciones particulares

            let a = 1 / 0; // Infinity
            let b = 0 / 0; // NaN
            let c = -a; // -Infinity
            let d = 1 / c; // -0

      NaN significa "Not a Number"
        es el resultado de una operación aritmética y no es un valor null ni tampoco undefined
          es por eso que tiene sentido definir un valor especial inválido para este caso de Number

  BigInts

    un tipo de dato que puedo no tener límites
    en nuestro universo digital, hay un número infinito de BigInts, uno por cada entero que conocemos en matemáticas
    según las especificaciones, los BigInts tienen precisión arbitraria

    ejm
      let cuchuMil = 9007199254740991n; // ¡La "n" al final lo convierte en un BigInt!
      console.log(cuchuMil + 1n); // 9007199254740992n
      console.log(cuchuMil + 2n); // 9007199254740993n
      console.log(cuchuMil + 3n); // 9007199254740994n
      console.log(cuchuMil + 4n); // 9007199254740995n
      console.log(cuchuMil + 5n); // 9007199254740996n

    los BigInts no tienen problemas con redondeos y son ideales para cálculos financieros
      donde la precisión es fundamental

    la desventaja es que la s operaciones con números extremadamente grandes pueden consumir tiempo y recursos
      no podemos albergar todos los BigInts posibles en la memoria de una computadora
        si lo intentáramos, tarde o temprano, nuestra máquina colapsaría

    * Los BigInts son una incorporación reciente en JavaScript, por lo que aún no son ampliamente utilizados.

  Strings (o tambien llamados Cadenas de texto)

    existen dos formas de definir literalmente un String cadena: usando comillas simples o comillas dobles
      console.log(typeof("¡Hola!")); // "string"
      console.log(typeof('¡Hola!')); // "string"

    un String vacío sigue siendo un String válido:

      console.log(typeof('')); // "string"

    existe una tercera forma de crear una cadena
      utilizando un "template string" (plantilla de texto)
        un template string se crea utilizando tildes invertidas (backticks)

          console.log(typeof(`Template String`)); // "string"

        permite incrustar expresiones dentro de la cadena
          que se evaluarán y se convertirán en su valor correspondiente cuando la cadena se interpreta
            las expresiones que se colocan entre ${} son evaluadas por el motor de JavaScript
              y su resultado es convertido a String para ser incrustado en la cadena inicial

              `La suma de 5 + 4 es ${5 + 4}`; // 'La suma de 5 + 4 es 9'

  Symbols
