Igualdad Estricta: a === b (triple igual).
Igualdad Débil: a == b (doble igual).
Igualdad de Mismo Valor: Object.is(a, b).


Same Value Equality: Object.is(a, b)
  Object.is(a, b)
    retorna true o false dependiendo si a y b son el mismo valor:

      console.log(Object.is(2, 2)); // true
      console.log(Object.is({}, {})); // false

    para cuando se trata de objetos
      recuerda que cada vez que utilizas el literal {}, estas creando un nuevo objeto

      ejemplo
        let manzana = {};
        let pera = manzana;
        let naranja = pera;
        pera = {};

        console.log(Object.is(manzana, pera)); // false
        console.log(Object.is(pera, naranja)); // false
        console.log(Object.is(naranja, manzana)); // true

          * toma en cuenta mis primeras impresiones eran estas
            console.log(Object.is(manzana, pera)); // false
            console.log(Object.is(pera, naranja)); // true
            console.log(Object.is(naranja, manzana)); // false

              mi modelo mental estaba mal
                pensaba que la redireccion de pera a un nuevo objeto cambiaria tambien la de naranja
                  pero no, una vez ya se ejecuta la linea de let naranja = pera
                    se queda naranja apuntando al objeto original
                      y luego cuando pera se reasigna al nuevo objeto, para ese momento naranja ya no esta ligado a pera

                        al final de estas lineas el modelo mental queda asi
                          manzana apunta al primer objeto creado
                          pera apunta al segundo objeto creado
                          naranja apunta al primer objeto creado

  Object.is vs ===

    Object.is tenía una clara correspondencia en nuestro modelo mental
    las variables que apuntan al mismo valor tienen "igualdad de mismo valor"

    en casi todos los casos, la misma intuición funciona para la igualdad estricta
      ejemplo
        2 === 2 es verdadero porque 2 siempre "invoca" el mismo valor
        {} === {} es falso porque cada {} crea un valor diferente

    hay dos casos raros donde
      el comportamiento de === es diferente de Object.is
        considéralos como excepciones a la regla

        NaN === NaN es falso, aunque son el mismo valor.
        -0 === 0 y 0 === -0 son verdaderos, aunque son valores diferentes.

    si necesitas verificar si una variable es NaN tienes las siguientes alternativas
      let resultado = NaN;
      resultado === NaN; // false

      // Alternativas:
      Object.is(resultado, NaN); // true
      Number.isNaN(resultado); // true
      resultado !== resultado; // true // muy hacky. recomendado usar las 2 primeras
