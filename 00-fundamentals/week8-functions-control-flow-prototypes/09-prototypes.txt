prototipos intro

  como es esto posible?

    let spiderman = {};
    console.log(spiderman.identidad); // output: "Peter Parker"

  usualmente obtenemos undefined cuando una propiedad no existe
    esto es gracias a los prototipos

prototipos concepto
  ejemplo
    let humano = {
      corazon: true
    };

    let maryJean = {
      pelo: "rojo"
    };

    // si luego hacemos esto obtenemos undefined
    console.log(maryJean.corazon); // undefined

    // pero podemos indicarle para que continúe buscando la propiedad faltante en otro objeto
    maryJean.__proto__ = humano;

    // y luego obtendriamos esto
    console.log(maryJean.corazon); // true


  __proto__ no es una propiedad
    sino un setter de una propiedad oculta llamada [[Prototype]]
      el valor que asignamos a __proto__ se convierte en el prototipo del objeto

  Como una analogia muy simple
    Es como cuando te hacen una pregunta y tu respondes
      "Yo no se, pero quizá Pepito sabe, pregúntale a él."
        Cuando una propiedad no existe en un objeto, JavaScript le "preguntará" a su prototipo

cadena de prototipos
  se busca por todos los prototipos hasta que se encuentra la propiedad que se busca
    si no se encuentra ahí recién se manda un error

  ejemplo
    let mamifero = {
      poneHuevos: false
    }

    let humano = {
      corazon: true
    };

    humano.__proto__ = mamifero;

    let maryJean = {
      pelo: "rojo"
    };

    maryJean.__proto__ = humano;

    console.log(maryJean.poneHuevos); // false

shadowing
  si una propiedad ya se encuentra, no importa si su prototipo tiene la misma propiedad
    se devuelve la primera propiedad que se encuentra en la cadena

  ejemplo
    let humano = {
      corazon: true
      pelo: "natural",
    };

    let maryJean = {
      pelo: "rojo"
    };

    maryJean.__proto__ = humano;

    console.log(humano.pelo); // "natural"
    console.log(maryJean.pelo); // "rojo"

  si quieres saber si un objeto tiene una propiedad definida en si mismo
    o si su propiedad viene por prototipos
      puedes usar hasOwnProperty

        ejemplo
          console.log(humano.hasOwnProperty('pelo')); // true
          console.log(maryJean.hasOwnProperty('pelo')); // true

asignaciones de propiedades sabiendo que existen prototipos
  asi tengas un prototipo con una propiedad que no se tiene
    si se asigna un valor a esa propiedad no se asigna a su objeto 'padre' prototipo
      se asigna al mismo objeto que no tenia esa propiedad

  ejemplo
    let humano = {
      corazon: true
    };

    let maryJean = {
      pelo: "rojo"
    };

    maryJean.__proto__ = humano

    maryJean.corazon = false;

    console.log(humano.corazon); // true
    console.log(maryJean.corazon); // false

prototipo del objeto por defecto
  let obj = {};
  console.log(obj.__proto__); // no es 'null' ni 'undefined'

  obj.__proto__ apunta al Prototipo por defecto
    este tiene funciones del objeto como
      .toString
      .hasOwnProperty
      etc

  esto explica porque todos los objetos parecen tener propiedades 'integradas'
    son solo las propiedades normales en el Prototipo de Objeto por defecto
      ejm
        let humano = {
          corazon: true
        };
        console.log(humano.hasOwnProperty); // (función)
        console.log(humano.toString); // (función)

contaminacion del prototipo
  a este punto seguro ya tienes una idea de como puede ocurrir esto
    let spiderman = {};
    console.log(spiderman.identidad); // "Peter Parker"

  la única manera de que la propiedad identidad retorne "Peter Parker"
    es agregando esta propiedad al Prototipo de Objeto

      let spiderman = {};
      spiderman.__proto__.identidad = "Peter Parker";

      let batman = {};

      console.log(spiderman.identidad); // "Peter Parker"
      console.log(batman.identidad); // "Peter Parker"

  mutar un prototipo compartido por diferentes objetos
    es conocido como "Contaminación del Prototipo"

  antes esta técnica se utilizó para agregar funcionalidad a JavaScript
    pero actualmente se considera una mala práctica
      porque es mejor evitar posibles conflictos de nombres de propiedades
        ya que JavaScript evoluciona constantemente

otras observaciones de __proto__
