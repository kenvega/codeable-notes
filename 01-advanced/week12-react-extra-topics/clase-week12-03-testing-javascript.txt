por que importa el testing

  asegura la calidad y fiabilidad:

  facilita la mantenibilidad
    a medida que una aplicación crece, el testing se vuelve crucial para
      asegurar que los nuevos cambios no rompan funcionalidades existentes (conocido como 'regresiones')

  mejora la experiencia del usuario

  reduce costos a largo plazo
    detectar y solucionar errores en las etapas iniciales del desarrollo es mucho menos costoso
      que hacerlo después de que el software ha sido desplegado

  apoya el desarrollo ágil
    es un pilar en metodologías ágiles como Scrum o Kanban
    permite a los equipos desarrollar iterativamente y responder a cambios con mayor agilidad
      sabiendo que los tests proporcionan una red de seguridad contra errores inadvertidos

fundamentos de testing
  la forma más fundamental de escribir un test es
    simplemente un código que lanzará un error cuando el resultado no sea lo que esperamos

  si no se lanza un error entonces el test pasa


aserciones (afirmaciones) y bibliotecas de aserciones

  aserción o afirmación en el contexto de testing se refiere a una expresión que describe qué esperamos que ocurra

    ejm: "Espero que el valor actual de sum(3, 4) sea el número 7"

  una biblioteca de aserciones ayuda a que el código de prueba se lea de manera similar a la frase de arriba

    esto ayuda a que el código refleje de manera clara la intención del desarrollador al escribir el test

  ejm de como hacer una biblioteca de aserciones

    // La función 'expect' recibe un valor y retorna un objeto con métodos para ejecutar afirmaciones sobre ese valor:
    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`${actual} no es igual a ${expected}`);
          }
        },
        //... otras afirmaciones como toBeGreaterThan, toBeNull, toBeTruthy, etc.
      };
    }

    // Funciones a probar
    function sum(a, b) {
      return a + b;
    }

    function substract(a, b) {
      return a - b;
    }

    // probando la función 'sum'
    expect(sum(3, 4)).toBe(7);

    // Prueba substract
    expect(substract(10, 6)).toBe(4);

construir un framework de testing

  si un expect falla/lanza un error entonces no se ejecutaran los siguientes

  ejemplo de testing framework:

    // test recibe un titulo (string) y una función callback
    // que encapsula la lógica del test

    function test(title, callback) {
      try {
        callback();
        console.log(`✓ ${title}`);
      } catch (error) {
        console.error(`✕ ${title}`);
        console.error(error);
      }
    }

    // ...
    // ... el mismo codigo ejemplo de la biblioteca de aserciones y definicion de funciones
    // ...

    // usando test al ejecutar todo el codigo se puede ver si cierto test paso pero ya con la intencion de cada test en los logs
    // Prueba sum
    test("sum suma 2 números", () => {
      const result = sum(3, 4);
      const expected = 7;
      expect(result).toBe(expected);
    });

    // Prueba substract
    test("substract resta 2 números", () => {
      const result = substract(10, 6);
      const expected = 4;
      expect(result).toBe(expected);
    });

soportar pruebas asincronas
  tendrias que cambiar la funcion test para soportar cosas asincronas

    async function test(title, callback) {
      try {
        await callback();
        console.log(`✓ ${title}`);
      } catch (error) {
        console.error(`✕ ${title}`);
        console.error(error);
      }
    }
    // ...
    async function sumAsync(a, b) {
      return a + b;
    }
    // ...
    test("sum suma 2 números de manera asíncrona", async () => {
      const result = await sumAsync(3, 4);
      const expected = 7;
      expect(result).toBe(expected);
    });

jest and vitest

  ambos son framework de pruebas

  jest
    más popular biblioteca de testing para JavaScript
    conocida por su simplicidad y facilidad de uso, especialmente en aplicaciones desarrolladas con React
    solución completa para pruebas en JavaScript
      tiene incorporadas todas las herramientas necesarias para escribir y ejecutar pruebas

    caracteristicas
      zero-configuration
        diseñado para ser utilizado con mínima configuración
          permite a los desarrolladores comenzar a escribir pruebas rápidamente

      mocking fácil
        ofrece una forma sencilla de simular módulos, timers y otros aspectos de tu aplicación
          útil para pruebas unitarias aisladas.

      cobertura de código integrada
        jest puede generar informes de cobertura de código para saber qué partes del código no están siendo probadas.

      snapshot testing
        permite a los desarrolladores capturar "instantáneas" del estado de los componentes de react
        y otros datos de la UI para detectar cambios no deseados a lo largo del tiempo.

      compatible con typescript
        se integra bien con typescript
          permite escribir pruebas para proyectos basados en este superset de javascript

      ejecución paralela de pruebas
        jest ejecuta pruebas en paralelo
          acelera el proceso de testing, especialmente en proyectos grandes.

      entornos de prueba configurables
        puede simular entornos de navegador y node.js
          util para pruebas que dependen de características específicas de estos entornos

  vitest
    framework de pruebas moderno para JavaScript
    diseñado como una alternativa más rápida y eficiente a otros frameworks como Jest
    especialmente adecuado para proyectos que utilizan Vite

    caracteristicas
      alta velocidad
        aprovecha la arquitectura de vite para ofrecer
          tiempos de inicio rápidos y una recompilación eficiente
            resulta en una experiencia de prueba más rápida

      soporte nativo ESM
        al estar construido sobre vite, vitest soporta nativamente módulos ESM
        lo cual está en línea con las tendencias modernas de desarrollo de javascript

      compatible con jest
        diseñado para ser compatible con jest
          permite a los usuarios migrar fácilmente sus pruebas existentes de jest a vitest

Usando Vitest
  documentacion
    https://vitest.dev/guide/

  instalar vitest
    npm install -D vitest

  agregar script a package.json
    {
      "scripts": {
        // ...otros scripts,
        "test": "vitest"
      }
    }

  nombrar archivos que contienen tests con .test.js o .test.jsx o .test.ts o .test.tsx

    cuando ejecutas vitest se ejecutan todos eso archivos

      si pones el ejemplo de las pruebas que se mencionaban anteriormente
        en un archivo como my-test.test.js
          se ejecutarian estas pruebas con vitest

  ejecutar vitest

    npm run test

      esto corre vitest en modo watch (checa los archivos de tests por algun cambio)

puedes chequear las aserciones que vienen en vitest aqui

  https://vitest.dev/api/expect.html

otras consideraciones para armar tests

  la funcion it
    es un alias de la funcion 'test' (es lo mismo)
      pero encaja mejor al escribir el test como una frase

  describe
    solamente una forma de agrupar tus tests
      para que aparezcan juntos en los resultados de las pruebas
      cuando se ejecutan todas las pruebas con el comando

  metodos it.todo y it.skip
    it.todo: el metodo aun no esta completo asi que no se ejecutara
    it.skip: el metodo esta completo pero por alguna razon no lo ejecutaremos

  metodo expect.hasAssertions()
    si un test no lanza un error siempre pasara
      pero si no haces nunca un expect dentro del test entonces nunca lanzara un error
        y esos serian falsos positivos
          expect.hasAssertions() se asegura de que tengas al menos un expect en tu test