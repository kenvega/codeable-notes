* la primera clase de node se dio la semana pasada el viernes
    pero se consider贸 ponerlo todo en un mismo archivo para esta semana


introduccion a node

  ofrece soluciones eficientes
  escalables
  puede manejar millones de usuarios sin presentar bloqueos

  tiene naturaleza no bloqueante

  est谩 orientada a eventos

  versatil
    puedes crear paginas web simples como aplicaciones muy complejas

  tiene integracion con Electron
    asi que con node puedes crear apps para Mac y windows
      y con Ionic puedes crear apps mobiles tmb

  otra ventaja es poder construir aplicaciones complejas
    de principio a fin usando un solo lenguaje

objetivo
  construir aplicaciones web (principalmente RESTful APIs) usando node.js

la web: arquitectura cliente - servidor
  al abrir una pagina web / aplicacion web

    - para que el navegador muestro "algo" en la pantalla
        primero necesita saber qu茅 archivos procesar (HTML, CSS, JavaScript, im谩genes, etc.).

    - para obtener esos archivos
        el usuario escribe una url en la barra de direcciones y presiona 'enter'
        digamos que la url es: http://server.com/index.html

    - el navegador inicia una solicitud/request y la env铆a por internet
        esa solicitud contiene la informaci贸n necesaria para
          viajar desde la tarjeta de red del cliente,
          pasando por el router/modem de su hogar, por la red de computadoras interconectadas (Internet),
          hasta llegar a su destino:
            el servidor ubicado en la direcci贸n server.com

    - un servidor no es m谩s que una computadora que esta ejecutando un programa que su tarea es "escuchar"
        cualquier solicitud que pueda llegar y retornar una respuesta adecuada.

    - cuando la solicitud llega al servidor, este inspecciona la solicitud y determina qu茅 proceso realizar
        en este caso, se est谩 solicitando el recurso/archivo llamado index.html

    - el servidor accede a su sistema de archivos (su disco duro) y busca el archivo requerido
        si lo encuentra, copia su contenido y lo agrega al mensaje de respuesta (response)

    - agrega tambi茅n informaci贸n adicional entre la cual se encuentra el c贸digo de estado
        como el archivo index.html se encontr贸 exitosamente y ser谩 retornado, el c贸digo de estado ser谩 "ok" (c贸digo 200)

    - una vez el mensaje de respuesta esta completo
        el servidor lo env铆a de vuelta al cliente por medio de su tarjeta de red
        este mensaje viaja una ve m谩s por internet hasta llegar a la computadora del cliente

    - el cliente recibe el mensaje de respuesta y lo procesa mostrando en la pantalla el archivo HTML recibido

  las solicitudes tambien se pueden hacer asi
    formularios web
    solicitudes por JavaScript con fetch

  una solicitud, de manera general, es un mensaje que dispara una acci贸n en el servidor
    esa acci贸n puede ser realmente cualquier cosa

    tambien se puede devolver archivos en formato json

  entonces el servidor puede
    escuchar por la red solicitudes
    leer su disco duro

    esto antes no se podia hacer con js hasta que llego node


Node js

  para poder acceder a las caracter铆sticas internas de la computador
    tarjeta de red, sistema de archivos, etc.
      Node.js est谩 construido en base al motor V8 de Google que est谩 escrito en C++
        aunque escribamos nuestro c贸digo en JavaScript
          este se ejecuta en un entorno que est谩 profundamente arraigado en C++

  node proporciona un conjunto de m贸dulos a trav茅s de una API de alto nivel
    dise帽ada para ser utilizada directamente en JavaScript

    estos m贸dulos abstraen muchas de las funcionalidades de bajo nivel
      permiten a los desarrolladores
        trabajar con redes, sistemas de archivos, y otras operaciones de sistema
          sin tener que sumergirse en C++ o detalles de bajo nivel

        interactuar directamente con el sistema operativo y el hardware de la computadora
          de formas que no son posibles ejecutando JavaScript en un navegador

  entre los m贸dulos m谩s importantes del n煤cleo de Node.js se encuentran
    - http: para crear servidores HTTP y realizar peticiones como cliente

    - fs: funciones para leer y escribir archivos, y manipular el sistema de archivos

    - path: manejo y transformaci贸n de rutas de archivos y directorios

    - os: proporciona informaci贸n y control sobre el sistema operativo

    - events: facilita la creaci贸n y gesti贸n de eventos y la clase EventEmitter

    - stream: trabajo con flujos de datos (streams) para lectura y escritura eficiente

    - buffer: manejo de datos binarios a trav茅s de secuencias de bytes

    - child_process: ejecuci贸n de procesos externos y comandos del sistema

    - url: utilidades para la resoluci贸n y an谩lisis de URLs

    - crypto: funciones de criptograf铆a para seguridad

    - dns: consultas DNS y resoluci贸n de nombres de dominio

    - net: creaci贸n de aplicaciones basadas en protocolos de red (TCP, IPC)

    - tls/sl: implementaci贸n del protocolo TLS/SSL para comunicaciones seguras

  * el objetivo de Node.js es que podamos
      escribir el c贸digo JavaScript que ya conocemos (declarar variables, funciones, etc.)
        y delegar las tareas de bajo nivel a los m贸dulos del n煤cleo de Node.js

setup de proyecto de node con typescript

    commandos para el setup
        mkdir node-playground

        cd node-playground

        npm init -y # this creates the package.json file

        npm install -D typescript @types/node nodemon ts-node

    librerias que se instalan
        @types/node: proporciona definiciones de tipos TypeScript para los m贸dulos del n煤cleo de Node.js
                      permite tener autocompletado y verificaci贸n de tipos para las API de Node.js

        nodemon: monitorea los cambios en el c贸digo fuente y reinicia autom谩ticamente el servidor
                    para no tener que reiniciarlo manualmente cada vez que hacemos cambios en el c贸digo

        ts-node: permite ejecutar directamente aplicaciones escritas en TypeScript en Node.js
                    sin necesidad de compilar previamente el c贸digo TypeScript a JavaScript

    comandos para la configuracion del servidor
        npx tsc --init
            este comando genera el archivo tsconfig.json
              este archivo le dice como compilar el codigo typescript a javascript

    lo puedes modificar
        {
          "compilerOptions": {
            /* Language and Environment */
            "target": "ESNext",

            /* Modules */
            "module": "NodeNext",
            "rootDir": "./src",

            /* Emit */
            "outDir": "./build",

            /* Interop Constraints */
            "esModuleInterop": true,
            "forceConsistentCasingInFileNames": true,

            /* Type Checking */
            "strict": true,
            "noImplicitThis": true,
            "useUnknownInCatchVariables": true,
            "noUnusedLocals": true,
            "noUnusedParameters": true,
            "noImplicitReturns": true,
            "noFallthroughCasesInSwitch": true,
            "noImplicitOverride": true,
            "noPropertyAccessFromIndexSignature": true,

            /* Completeness */
            "skipLibCheck": true
          }
        }

    crea un index.js
        mkdir src
        touch src/index.ts

    pon codigo en tu index.js
        console.log("Node.js + TypeScript");

    a帽ade scripts a package.json
        ...
        "scripts": {
          "dev": "nodemon src/index.ts",
          "build": "tsc",
          "start": "node build/index.js",
          "test": "echo \"Error: no test specified\" && exit 1"
        },
        ...

        explicacion
          dev: ejecuta src/index.ts usando nodemon
                  se podr谩 ejecutar directamente sin necesidad de compilar
                  gracias a la librer铆a node-ts que instalamos previamente
                  adicionalmente nodemon volver谩 a ejecutar el archivo cada vez que detecte un cambio

          build: ejecuta tsc para compilar el c贸digo TypeScript a JavaScript en el directorio build

          start: ejecuta el archivo build/index.js utilizando node ("versi贸n de producci贸n")

    puedes ejecutar luego
        npm run dev

* sobre las opciones de configuracion en tsconfig.json
    por defecto venia con esta config
      verbatimModuleSyntax: true (significa no reescribas los imports/exports a commonJS)

        cuando se remueve esto
          se mantiene el proyecto con commonJS (el estilo antiguo en node)

          aun se puede escribir codigo en typescript con syntaxis moderna como
            import http from "node:http";

          pero cuando se transpile se terminara usando commonJS
            // build/index.js (generated)
            "use strict";
            var http_1 = require("node:http"); //  TS rewrote this

        tambien se puede poner el proyecto ESM (modern module system)

          en package.json se agrega
            {
              "type": "module"
            }

          asi se puede mantener estas configs de tsconfig.json intactas como venian por defecto
            "module": "nodenext",
            "verbatimModuleSyntax": true

          de esta forma typescript ya no reescribe los imports a require

            cuando node checa el package.json y ve el type: module
              notara que el proyecto usa ES modules asi que correr谩 los imports/exports de manera nativa

